#!/usr/bin/env python
from __future__ import print_function

from os import mkdir, listdir
from os.path import join, exists
from datetime import datetime

from subprocess import check_call

from yaml import load
from json import loads, dumps

import argparse
import sys


# Ohsnap RPC version recognition string
# This is used by the client to detect server readiness to receive commands
# The protocol is client driven, at no point will the server act without the
# client initiating activity.
ISSUE = '\nohsnap-RPC-v1'


def backup(name, dry_run=True):
    subvol = SUBVOLUMES[name]
    src = subvol['src']

    src_path = join(SNAPSHOT_PATH, name)
    if not exists(src_path) and not dry_run:
        mkdir(src_path)

    d = datetime.now().strftime('%Y-%m-%d')

    dest_path = join(src_path, d)

    if exists(dest_path):
        print('Snapshot %s already exists' % dest_path)
        return

    args = ['btrfs', 'subvolume', 'snapshot', '-r', src, dest_path]

    if dry_run:
        args = ['echo', 'DEBUG:'] + args

    return check_call(args)


def _get_snapshots(name, latest=False):
    src_path = join(SNAPSHOT_PATH, name)
    snapshots = sorted(listdir(src_path))

    if latest:
        if latest is True:
            snapshots = [snapshots[-1]]
        else:
            snapshots = list(filter(lambda x: x > latest, snapshots))

    return snapshots


def list_snapshots(name, prefix=True, latest=False):
    snapshots = _get_snapshots(name, latest)

    if prefix:
        print('%s: %s' % (name, ','.join(snapshots)))
    else:
        print(','.join(snapshots))


def send(name, snapshot=None, parent=None, dry_run=True):
    if snapshot is None:
        snapshot = _get_snapshots(name, latest=True)[0]

    send_path = join(SNAPSHOT_PATH, name)

    snap_path = join(send_path, snapshot)

    args = ['btrfs', 'send']

    if parent is not None:
        parent_path = join(send_path, parent)
        args += ['-p', parent_path]

    args += [snap_path]

    if dry_run:
        args = ['echo', 'DEBUG:'] + args

    return check_call(args)


def receive(name, dry_run=True):
    rec_path = join(SNAPSHOT_PATH, name)

    args = ['btrfs', 'receive', rec_path]

    if dry_run:
        args = ['echo', 'DEBUG:'] + args

    return check_call(args)


# NOTE: By no means is this function meant to be secure
# this protocol is simply implemented on top of full
# SSH access as a means for ohsnap to sync multiple snapshots
def listen():
    '''
    Start RPC client main loop.
    '''

    print(ISSUE)

    for line in sys.stdin:
        cmd = loads(line)
        func = cmd['func']
        pargs = cmd['pargs']
        kargs = cmd['kargs']

        if func == 'quit':
            print('goodbye')
            return

        globals()[func](*pargs, **kargs)
        print(ISSUE)


parser = argparse.ArgumentParser(description='ohsnap btrfs snapshot manager',
                                 epilog='ohsnap is *highly* *experimental* and'
                                        ' should not be considered ready for'
                                        ' any usage.')

parser.add_argument('--config', default='ohsnap_config.yml',
                    help='Config file to use. Default: ohsnap_config.yml')
parser.add_argument('-p', '--parent', default=None,
                    help='Snapshot to use as parent for incremental sending')

actions = parser.add_argument_group('Actions')
actions.add_argument('-l', '--list', action='store_true',
                     help='List available snapshots')
actions.add_argument('-c', '--create', action='store_true',
                     help='Create (daily) snapshot')
actions.add_argument('-S', '--send', action='store_true',
                     help='Send snapshot to stdout')
actions.add_argument('-R', '--receive', action='store_true',
                     help='Receive snapshot from stdin')

# RPC commandset
actions.add_argument('-C', '--listen', action='store_true',
                     help='Listen in RPC mode for commands')

match = parser.add_argument_group('Match')
match.add_argument('-s', '--subvolume', type=str, default=None,
                   help='Work only on a specific subvolume')
match.add_argument('-x', '--snapshot', type=str, default=None,
                   help='Specify a certain snapshot of a subvolume/remote')
match.add_argument('-L', '--latest', action='store_true',
                   help='List/Use only newest snapshots')
match.add_argument('-N', '--next', type=str,
                   help='List/Use snapshots newer than specified snapshot')

modifiers = parser.add_argument_group('Modifiers')
modifiers.add_argument('-n', '--dry-run', action='store_true',
                       default=False,
                       help='')
modifiers.add_argument('--debug-config', action='store_true',
                       help='Output interpreted configuration file')

args = parser.parse_args()


def multiple(x):
    '''
    Check if multiple items in x evaluate to True
    '''

    return sum(map(int, x)) > 1

if multiple((args.list, args.create, args.send, args.receive)):
    print('You cannot perform different kinds of actions the same time.')
    parser.print_help()
    exit(1)

with open(args.config) as t:
    c = load(t.read())

if args.debug_config:
    from pprint import pprint
    pprint(c)

SNAPSHOT_PATH = c['snapshot_path']
SUBVOLUMES = c.get('subvolumes', {})
REMOTES = c.get('remotes', {})

# Merge all volumes into single dict
ALL = SUBVOLUMES.copy()
ALL.update(REMOTES)

# NOTE: If latest is True _get_snapshots will return a list
# containing only the most recent snapshot for specified targets.
# Otherwise, if latest is False it will return all snapshots for a target.
# Finally, if latest is a string, _get_snapshots will return a list of
# snapshots, more recent than the snapshot specified.
if args.next:
    args.latest = args.next

if args.list:
    if args.subvolume:
        list_snapshots(args.subvolume, prefix=False, latest=args.latest)
    else:
        for k in ALL:
            list_snapshots(k, latest=args.latest)

elif args.create:
    if args.subvolume:
        backup(args.subvolume, dry_run=args.dry_run)
    else:
        for k in SUBVOLUMES:
            backup(k, dry_run=args.dry_run)

elif args.send:
    if args.subvolume:
        if not args.latest and args.snapshot is None:
            print('Must either specify a specific snapshot, or '
                  '--latest/--next '
                  'for sending the latest/next snapshot')
            exit(1)

        send(args.subvolume, snapshot=args.snapshot, parent=args.parent,
             dry_run=args.dry_run)
    else:
        print('The subvolume to send must be specified')
        exit(1)

elif args.receive:
    if args.subvolume:
        receive(args.subvolume, dry_run=args.dry_run)
    else:
        print('The remote to receive must be specified')

elif args.listen:
    listen()

else:
    parser.print_help()
    exit(1)
